数据结构及算法设计
一．基本算法步骤
算法以与/或树搜索为基础，删去其中的hj的计算和Pj的设置，只在生成子节点的时候进行按方法进行排序。
	1)	初始化open_table和closed_table，把初始节点（序号0）放入open_table
	2)	如果open_table=空，算法失败终止；否则转步骤3
	3)	把open_table中尚未标示可解/不可解标志的第一个节点移出，放入closed_table表尾
	4)	若节点i可扩展，则用可以算符作用于节点i的Si，生成其子节点j；否则转6 
		a)	若子节点j的问题表示既不在open_table中，也不在closed_table中，则节点j是一个新节点，记录j的各个域，并将其放入open_table中，转2
		b)	若子节点j的问题表示已在open_table或closed_table中，放弃新节点j，转2
	5)	若子节点j是终叶节点（农民剩牌为空），则标示节点j可解，并调用可解标示过程。若可解标识过程把初始节点标示为可解，则算法成功终止；否则转2
	6)	若节点不可扩展（地主剩牌为空），则标示节点不可解，并调用不可解标示过程。若不可解标示过程把初始节点标示为不可解，则问题无解，算法终止；否则删除节点i在open_table和closed_table中的所有后裔节点，转2

可解/不可解标示过程是自下而上的，假设i是j的父节点，如果：
	1)	j为终叶节点，如果i是或节点，则i将被标示为可解；如果i是与节点，则要判断i的其他子节点是否可解，如果都可解则将i标示为可解
	2)	j为不可解节点，如果i是与节点，则i将被标示为不可解；如果i是或节点，则要判断i的其他子节点是否可解，如果都不可解，则将i标示为不可解
详细算法见后。

二．节点数据结构
节点包括以下域：
1)	j：节点编号，整型，初始节点为0
2)	i：父节点编号，整型
3)	Sj：节点j状态，节点j状态是一个结构，包括以下域：
	Dizhu：地主剩牌，字符串
	Nongmin：农民剩牌，字符串
	Xianshou：当前出牌人，bool型，true农民，false地主
	Must_go：是否必须出牌，bool型，true必须出，false可以不出
4)	Fk：算符，结构类型，包括以下三个域：
	fk_cards：字符串，算符值
	fk_class：字符，算符种类（这是一个冗余数据，用于在跟牌的时候直接调用这种类型的算符，而不需要再由字符串判断）
	fk_base：字符，算符基本张（用于大小比较的基本张，如：三带一9994的基本张为9，顺子987654的基本张为4，等等）
5)	And_or：与节点还是或节点，bool型，true与节点，false或节点
6)	Y_n：可解或者不可解节点，整型，0可解，1不可解，2未标记；可解定义为农民胜，不可解定义为地主胜
7)	Hj：解树代价估计值，本题不用，节点不多，问题简化为可解和不可解标记，不计算代价gj和hj
8)	Pj：希望标志，bool型，保留，暂没想到有什么用
9)	Note：说明，字符串
Open_table和closed_table都实现为节点的链表。

三．算符，即出牌规则
出牌分成两种情况，第一种是上一手牌本方大，对方不跟（父节点Fk=空串），称为自由出牌，这时本方必须出牌，至少出一张；第二种是跟牌，跟牌时必须根据对方上一手的出牌来决定。
	1. 自由出牌
	允许的出牌规则包括[1]：
		A.	单张：大小顺序从3(最小)到大怪(最大)；
		B.	一对：两张大小相同的牌，从3(最小)到2(最大)；
		C.	三张：三张大小相同的牌；
		D.	三带一：三张并带上任意一张牌，例如6-6-6-8，根据三张的大小来比较，例如9-9-9-3盖过8-8-8-A；
		E.	三带一对：三张并带上一对，类似扑克中的副路(Full House)，根据三张的大小来比较，例如Q-Q-Q-6-6盖过10-10-10-K-K，本题目中不允许；
		F.	顺子：至少5张连续大小(从3到A，2和怪不能用)的牌，例如8-9-10-J-Q；
		G.	连对：至少3个连续大小(从3到A，2和怪不能用)的对子，例如10-10-J-J-Q-Q-K-K；
		H.	三张的顺子：至少2个连续大小(从3到A)的三张，例如4-4-4-5-5-5；
		I.	飞机：每个三张都带上额外的一个单张，例如7-7-7-8-8-8-3-6，尽管三张2不能用，但能够带上单张2和怪；
		J.	三张带一对的顺子：每个三张都带上额外的一对，只需要三张是连续的就行，例如8-8-8-9-9-9-4-4-J-J，尽管三张2不能用，但能够带上一对2（不能带一对怪，因为两张怪的大小不一样），这里要注意，三张带上的单张和一对不能是混合的，例如3-3-3-4-4-4-6-7-7就是不合法的，三带对连在本题中也不允许；
		K.	四带二：有两种牌型，一个四张带上两个单张，例如6-6-6-6-8-9，或一个四张带上两对，例如J-J-J-J-9-9-Q-Q，四带二只根据四张的大小来比较，只能盖过比自己小的同样牌型的四带二（四张带二张和四张带二对属于不同的牌型，不能彼此盖过），不能盖过其他牌型，四带二能被比自己小的炸弹盖过。
		L.	这里将四带二分成四带二单和四带二对两种，K表示四带二单，L表示四带二对
		M.	炸弹：四张大小相同的牌，炸弹能盖过除火箭外的其他牌型，大的炸弹能盖过小的炸弹；
		N.	王炸：一对怪，这是最大的组合，能够盖过包括炸弹在内的任何牌型；
		
		在本方出牌时，对子节点进行排序，排序的依据是：
		1).	A到N按一次出牌张数最多排列，张数多的排前
		2).	优先级：如果一种方法能将所有牌出完，则其他方法全部不采用，只保留这一种
		
	2. 跟牌
	判断对方出牌种类和张数，然后得到本方出牌方法，调用大小规则判断，比对方出牌大的保留
	
	3.	大小规则
	设对方出牌为s1，则：
		1).	基本张大小顺序（有小到大排列）：3 4 5 6 7 8 9 10 J Q K A 2 小鬼 大鬼（10用单独的字符0代替）
		2).	A到K这些出牌中，张数相同，而且基本张比对方大（连牌（FGHIJ）的基本张按最小的算）：如对发出单张8，比它大的就是单张9以上；对方出飞机55566678，比它大的就是张数相同的飞机而且三张更大的如99900034；
		3).	M比上面的都大，如果都是M则比较基本张大小；
		4).	N最大，没比它大的了

四．输入/输出设计
	1. 输入
	直接使用字符串输入地主和农民的牌；
	2. 输出
	要求：按一定格式输出为文本文件，这个文件必须能通过其他工具（比如画图工具）重现打牌和可解/不可解节点的标示过程。
	文件具体格式如下：
		n1: n2	
		open: 节点编号
		closed: 节点编号
		n3 [节点编号1 节点编号2 ...]
		生成节点编号1 n4: 各个域的值
		生成节点编号2 n4: 各个域的值
		……
	其中：
		1)	n1表示编号，从1开始，每次考察一个节点，即从open_table中移除一个节点到close_table中，每次考察后n1增加1
		2)	n2表示所考察节点编号
		3)	Open这一行表示考察节点n2前的open表中的所有节点编号，节点之间用空格分隔
		4)	Closed这一行表示考察节点n2前的open表中的所有节点编号，节点之间用空格分隔
		5)	n3为数字，取值为0、1和2：为0表示调用节点可解标示过程，为1表示调用节点不可解标示过程，为2表示节点扩展过程
			a)	当n3取值为0或1时，节点必为可解节点或不可解节点，这时的最后一部分[…]内为标示的可解或不可解节点编号，这些节点按顺序依次表示，格式为“数字 数字 …”
			b)	当n3取值为2时，节点为未标记节点。在这种情况下，将产生各个新节点的编号和各个域的值。其中的n4为一个数字，为0表示新节点，为1表示节点在open_table中，为2表示节点在closed_table中。

五．文件及类结构
	1. C实现
	将函数及数据类型定义与实现分开，文件分为：
		cards.h：牌数据结构和函数定义
		cards_F.h：算符结构定义；
		cards_F.c：算符实现； 
		and_or_tree.h：用表实现的与/或树搜索的数据结构定义和函数定义
		and_or_tree.c：与/或树搜索的实现；
		play_cards.c：打牌过程的实现
		doudizhu.c：问题描述和问题的实现；
		Makefile
	
	2. Java实现
	Java语言中，表直接由链表和泛型实现，因此有以下3个类：
		Cards：定义牌数据结构；
		AndOrTree：与/或树搜索；
		Doudizhu：问题描述和实现

六．算法设计
	1. 自由出牌（free_play）
	输入：本方剩牌的字符串表示
	输出：本方的所有出牌方法，使用算符队列表示，并按一定方法排序
	条件：节点算符Fk为空串
	步骤：
		1)	按出牌规则，顺序为：NMALKBCDEFGHJI依次找到每种出牌规则下的算符，找到的算符依次加入算符队列头。其中查找单张、双张、三张、四张在同一个函数中实现。三带1实现方法是：先找到所有的三张，然后用原字符串删掉三张的字符串，生成所有的不同单张，再合并成3带一。其他类似。
		2)	判断算符是否能将牌出光。如果能，将不再进行其他规则的查找，输出队列中将只包含这一个算符；否则，将算符加入到算符队列中

	2. 跟牌
	输入：算符
	输出：新的算符队列
	条件：无
	步骤：
		1)	根据算符的类型调用相应的出牌规则，产生新的算符
		2)	判断新的算符是否比旧的算符大：如果是，判断能否把牌出光，如果能，则返回这一个算符；否则，这个算符不能出光牌，则将算符加入到算符队列
		3)	排序，将算符队列中所有算符的按规则大小排序，小的排前
		4)	将空算符（不出牌）放入队列末尾，返回
	
	3.	与/或树
	见一.

七．参考文献
	[1] http://baike.baidu.com/view/5574.htm，斗地主规则

